
We're going to create a Rust API for the Anthropic llms' new Messaging API. We'll use tokio reqwest serde serde_json as a start, we'll use dotenv to take the ANTHROPIC_API_KEY from env. let's start by making our client, and then implementing a create_message function on that client. Here is info about the bodies of messages:

Body Params
model
string
required

The model that will complete your prompt.

See models for additional details and options.
messages
array of objects
required

Input messages.

Our models are trained to operate on alternating user and assistant conversational turns. When creating a new Message, you specify the prior conversational turns with the messages parameter, and the model then generates the next Message in the conversation.

Each input message must be an object with a role and content. You can specify a single user-role message, or you can include multiple user and assistant messages. The first message must always use the user role.

If the final message uses the assistant role, the response content will continue immediately from the content in that message. This can be used to constrain part of the model's response.

Example with a single user message:

[{"role": "user", "content": "Hello, Claude"}]

Example with multiple conversational turns:

[
  {"role": "user", "content": "Hello there."},
  {"role": "assistant", "content": "Hi, I'm Claude. How can I help you?"},
  {"role": "user", "content": "Can you explain LLMs in plain English?"},
]

Example with a partially-filled response from Claude:

[
  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
  {"role": "assistant", "content": "The best answer is ("},
]

Each input message content may be either a single string or an array of content blocks, where each block has a specific type. Using a string for content is shorthand for an array of one content block of type "text". The following input messages are equivalent:

{"role": "user", "content": "Hello, Claude"}

{"role": "user", "content": [{"type": "text", "text": "Hello, Claude"}]}

Starting with Claude 3 models, you can also send image content blocks:

{"role": "user", "content": [
  {
    "type": "image",
    "source": {
      "type": "base64",
      "media_type": "image/jpeg",
      "data": "/9j/4AAQSkZJRg...",
    }
  },
  {"type": "text", "text": "What is in this image?"}
]}

We currently support the base64 source type for images, and the image/jpeg, image/png, image/gif, and image/webp media types.

See examples for more input examples.

Note that if you want to include a system prompt, you can use the top-level system parameter â€” there is no "system" role for input messages in the Messages API.
system
string

System prompt.

A system prompt is a way of providing context and instructions to Claude, such as specifying a particular goal or role. See our guide to system prompts.
max_tokens
integer
required

The maximum number of tokens to generate before stopping.

Note that our models may stop before reaching this maximum. This parameter only specifies the absolute maximum number of tokens to generate.

Different models have different maximum values for this parameter. See models for details.
metadata
object

An object describing metadata about the request.
stop_sequences
array of strings

Custom text sequences that will cause the model to stop generating.

Our models will normally stop when they have naturally completed their turn, which will result in a response stop_reason of "end_turn".

If you want the model to stop generating when it encounters custom strings of text, you can use the stop_sequences parameter. If the model encounters one of the custom sequences, the response stop_reason value will be "stop_sequence" and the response stop_sequence value will contain the matched stop sequence.
stream
boolean

Whether to incrementally stream the response using server-sent events.

See streaming for details.
temperature
number

Amount of randomness injected into the response.

Defaults to 1.0. Ranges from 0.0 to 1.0. Use temperature closer to 0.0 for analytical / multiple choice, and closer to 1.0 for creative and generative tasks.

Note that even with temperature of 0.0, the results will not be fully deterministic.
top_p
number

Use nucleus sampling.

In nucleus sampling, we compute the cumulative distribution over all the options for each subsequent token in decreasing probability order and cut it off once it reaches a particular probability specified by top_p. You should either alter temperature or top_p, but not both.

Recommended for advanced use cases only. You usually only need to use temperature.
top_k
integer

Only sample from the top K options for each subsequent token.

Used to remove "long tail" low probability responses. Learn more technical details here.

Recommended for advanced use cases only. You usually only need to use temperature. and here responses Response body
object
id
string
required

Unique object identifier.

The format and length of IDs may change over time.
type
const
required

Object type.

For Messages, this is always "message".
role
const
required

Conversational role of the generated message.

This will always be "assistant".
content
array of objects
required

Content generated by the model.

This is an array of content blocks, each of which has a type that determines its shape. Currently, the only type in responses is "text".

Example:

[{"type": "text", "text": "Hi, I'm Claude."}]

If the request input messages ended with an assistant turn, then the response content will continue directly from that last turn. You can use this to constrain the model's output.

For example, if the input messages were:

[
  {"role": "user", "content": "What's the Greek name for Sun? (A) Sol (B) Helios (C) Sun"},
  {"role": "assistant", "content": "The best answer is ("}
]

Then the response content might be:

[{"type": "text", "text": "B)"}]

model
string
required

The model that handled the request.
stop_reason
required

The reason that we stopped.

This may be one the following values:

    "end_turn": the model reached a natural stopping point
    "max_tokens": we exceeded the requested max_tokens or the model's maximum
    "stop_sequence": one of your provided custom stop_sequences was generated

Note that these values are different than those in /v1/complete, where end_turn and stop_sequence were not differentiated.

In non-streaming mode this value is always non-null. In streaming mode, it is null in the message_start event and non-null otherwise.
stop_sequence
required

Which custom stop sequence was generated, if any.

This value will be a non-null string if one of your custom stop sequences was generated.
usage
object
required

Billing and rate-limit usage.

Anthropic's API bills and rate-limits by token counts, as tokens represent the underlying cost to our systems.

Under the hood, the API transforms requests into a format suitable for the model. The model's output then goes through a parsing stage before becoming an API response. As a result, the token counts in usage will not match one-to-one with the exact visible content of an API request or response.

For example, output_tokens will be non-zero, even for an empty string response from Claude.
input_tokens
integer
required

The number of input tokens which were used.
output_tokens
integer
required

The number of output tokens which were used. we'll use thiserror to transparent and #from macro all the reqwest errors we may encounter and pretty env logger to log them eith error!s . lastly here's a sample curl for you to base our initial create_message off of:

Example Request
curl https://api.anthropic.com/v1/messages \
     --header "x-api-key: $ANTHROPIC_API_KEY" \
     --header "anthropic-version: 2023-06-01" \
     --header "content-type: application/json" \
     --data \
  '{
    "model": "claude-3-opus-20240229",
    "max_tokens": 1024,
    "messages": [
       {"role": "user", "content": "Hello, world"}
    ] '
  {

Example Response:
{ "content": [
    {
      "text": "Hi! My name is Claude.",
      "type": "text"
    }
  ],
  "id": "msg_013Zva2CMHLNnXjNJJKqJ2EF",
  "model": "claude-3-opus-20240229",
 "role": "assistant",
 "stop_reason": "end_turn",
 "stop_sequence": null,
 "type": "message",
 "usage": {
   "input_tokens": 10,
 }
}

 Remember to use only the most idiomatic and beautiful rust -- respond with code. assumer everything can go into the lib.rs and i'll organise it later. 

---------- Part II -------------

it looks like streaming is also supported to let's create a field in our client for streaming -- and if we're useing it use this create message instead: Raw HTTP Stream response We strongly recommend that use our client SDKs when using streaming mode. However, if you are building a direct API integration, you will need to handle these events yourself. curl https://api.anthropic.com/v1/messages \ --header "anthropic-version: 2023-06-01" \ --header "anthropic-beta: messages-2023-12-15" \ --header "content-type: application/json" \ --header "x-api-key: $ANTHROPIC_API_KEY" \ --data \ '{ "model": "claude-3-opus-20240229", "messages": [{"role": "user", "content": "Hello"}], "max_tokens": 256, "stream": true }' event: message_start data: {"type": "message_start", "message": {"id": "msg_1nZdL29xx5MUA1yADyHTEsnR8uuvGzszyY", "type": "message", "role": "assistant", "content": [], "model": "claude-3-opus-20240229, "stop_reason": null, "stop_sequence": null, "usage": {"input_tokens": 25, "output_tokens": 1}}} event: content_block_start data: {"type": "content_block_start", "index":0, "content_block": {"type": "text", "text": ""}} event: ping data: {"type": "ping"} event: content_block_delta data: {"type": "content_block_delta", "index": 0, "delta": {"type": "text_delta", "text": "Hello"}} event: content_block_delta data: {"type": "content_block_delta", "index": 0, "delta": {"type": "text_delta", "text": "!"}} event: content_block_stop data: {"type": "content_block_stop", "index": 0} event: message_delta data: {"type": "message_delta", "delta": {"stop_reason": "end_turn", "stop_sequence":null, "usage":{"output_tokens": 15}}} event: message_stop data: {"type": "message_stop"}
